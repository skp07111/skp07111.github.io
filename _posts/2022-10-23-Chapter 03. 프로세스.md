---
title: Chapter 03. 프로세스
date: 2022-10-23 +0900
categories: [Computer Science, Operating System]
tags: [CS, OS, operating system]
---
### Chapter 03 프로세스
▪ 운영체제는 정부와 같은 역할
- 어플리케이션에게는 하드웨어 사용의 편리함 제공
- 한정된 자원들을 여러 사용자들에게 공평하게 분배하며 자원의 이용을 극대화
- 운영체제는 다양한 프로그램을 실행한다. 운영체제에서 이런 프로그램들을 부르는 용어가 굉장히 다양한데, 하드디스크에 저장되어 있는 상태는 프로그램, 메모리 로드되면 프로세스, 순서를 기다리면 job, 유닉스 등에서는 task라고도 한다.
- 멀티프로그래밍: 메모리에 하나의 프로세스만 로드되어져서 일을 하는 것이 아닌 많은 프로세스들이 메모리에 올라가서 cpu를 사용하기 위해 경쟁하면서 cpu를 공유하는 시스템이다. cpu는 한순간에 하나의 프로세스만 처리가능하므로 한 프로세스가 실행중이면 다른 프로세스는 기다려야 한다. job은 이때 순서를 기다리는 프로그램을 의미한다. 
- 시분할 시스템: 여러 개의 프로그램들이 cpu 자원을 점유하지 못하도록 일정한 단위시간을 분배해서 그 시간 동안만 cpu를 사용할 수 있도록 하는 시스템을 시분할 시스템이라고 한다. 이 때, time slot에 프로세스들이 사용될 때는 프로세스를 task라고도 한다.

▪ 프로그램과 프로세스
- 프로그램은 수동적 개체로, 디스크에 저장되어 있다. 프로그램이 디스크에서 메모리에 로드 되는 순간, 프로그램은 프로세스가 됨.
- 프로세스는 능동적 개체로, 현재 cpu에 의해서 실행이 되고 있는 프로그램을 의미.
프로그램을 GUI 모드에서 더블클릭/CLI에서는 실행파일 이름 입력-> 디스크에 위치하고 있던 프로그램이 메모리로 로드가 됨, 이 때 하나의 프로그램은 코드 영역, 데이터 영역, 힙 영역, 스택 영역이라는 4개의 영역으로 나뉘어 메모리에 로드됨
- 코드 영역: 텍스트 영역이라고도 하며, 실행 파일의 명령어들이 있다.
- 데이터 영역: 정적 변수, 전역 변수들이 선언되어져 있다. 프로그램이 실행되거나 끝나는 동안에 변하지 않는 것들이 있다.
- 힙 영역: 프로그램 실행 중간에 메모리 할당이 필요한 경우 동적 할당하는 변수들을 저장하고 있다.
- 스택 영역: 지역 변수들이 저장되어 있다.

▪ 프로그램 카운터와 프로세스 레지스터: 프로세스가 생성이 되면 운영체제에서 메모리 관리 부서에 그 프로세스에 대한 정보를 등록하는데, 그 등록된 정보 중 일부이다.

▪ 프로세스의 생애 주기
- new: 프로세스가 메모리에 올라온 상태
- ready: 운영체제에 의해 프로세스 정보 등록, 해당 메모리 공간 초기화, cpu를 할당 받을 수 있는 준비된 상태
- running: cpu 디스패처에 의해서 실행이 되고 있는 상태. cpu 할당을 받으면 running.
- waiting: 프로세스가 어떠한 사건이 일어나기를 기다리고 있는 상태
- terminated: 프로세스가 실행을 완료한 상태




▪ 프로세스 제어 블록(pcb): 프로세스가 실행되면 메모리 할당 범위, 상태, 사용하는 장치 등 프로세스 정보를 운영체제에 등록을 해야 한다. 프로세스 제어 블록이라는 것은 각 프로세스에 대한 구조체를 생성하게끔 되어져 있고, 표 형식으로 서로 연결되어져 있다. 프로세스 제어 블록은 프로세스 한 개마다 하나씩 존재하는 자료구조로, 이 자료구조는 안에 프로세스의 정보들을 가지고 있으며 이걸 운영체제가 만든다. 운영체제의 프로세스 관리 부서에서 관리한다.
프로세스 제어 블록은 하나의 프로세스마다 각 한 개씩 모두 존재하며 ready 상태가 되었다는 것은 이미 운영체제의 하나의 프로세스에 대한 정보가 등록이 된 상태임을 의미한다.

▪프로세스 정보
- 프로그램 카운터(pc): 프로그램이 실행되다가 인터럽트가 걸려서 인터럽트 후 다시 복귀했을때 이전에 실행 중이던 값들이 유지가 되어야 내가 이전에 어디까지 했고 어디부터 시작해야 하는 지 알 수 있다. 이렇게 cpu로 돌아왔을 때 다음에 실행할 명령어의 주소를 알려주는 역할을 하는 것을 pc라고 한다.
- cpu 레지스터: cpu를 사용할 동안 자신의 작업을 하기 위한 연산이 진행되고 있었으면 cpu내 레지스터에 그 내용이 남으며, 이러한 내용들도 저장해놓아야 한다.
- cpu 스케줄링 정보: 우선순위, 스케줄링 큐 포인터
- 메모리 관리 정보: base와 limit 등 메모리 관련 정보
- 회계 정보: 운영체제는 현재 실행 중인 프로세스, CPU 사용량, 프로세스가 가지고 있는 자원 등 프로세스 정보/상태를 계속 감시
제한
- I/O 상태 정보: 프로세스에게 할당된 I/O 장치, pid가 연 파일 목록 등

▪ 스레드
- 한 프로세스가 여러 개의 스레드를 가진다 = 실행 흐름이 여러 개이다.
- 프로세스가 한 번에 하나 이상의 일을 수행한다. ex) ppt 프로그램: 키보드를 입력 & 입력한 키보드가 화면에 나옴 & 맞춤법 검사 & 네트워크를 이미지 불러오기를 동시에 진행한다.
- 하나의 프로세스가 실행될 때 여러 개의 스레드가 각자 맡은 일을 실행한다.
- 그러나 스레드를 제공해주는 운영체제에서만 실행 가능하며, 스레드를 제공하지 않는 운영체제에서는 사용 불가능하다. 현대의 운영체제들은 대부분 스레드를 지원한다.
- 확장된 pcb를 가져야 스레드 작업 유지가 가능하다.

▪ 프로세스 스케줄링
- 스케줄링의 목표는 cpu 이용의 극대화이며, 스케줄링의 대상은 큐이다.
* job queue: 용량이 큰 디스크에서 용량이 작은 메인 메모리로 올라가기 위해서 기다리는 장소
* ready queue: cpu를 사용하기 위해서 기다리는 장소로, 연결리스트로 구현되어 있다. (pcb와 동일한 구조이나 단방향이다.)
* device queue: 장치를 사용하기 위해서 기다리는 장소
- 프로세스는 생애 주기 동안 위와 같은 다양한 큐 사이를 왔다갔다 한다.

▪ 큐잉 다이어그램: 큐와 자원, 프로세스의 이동 흐름을 나타내는 다이어그램이다.

▪ 프로세스 타입
- i/o bound 프로세스: cpu에서의 연산보다 입출력에 더 많은 시간을 소모 (running << waiting/ready)
ex) 문서 편집기 - 키보드 입력/모니터 출력
- cpu bound 프로세스: 입출력보다 cpu 연산에 더 많은 시간을 소모 (running >> waiting/ready)

▪ 스케줄러
job queue, ready queue, device queue 와 같은 큐들이 얼마나 자주 호출되는지에 따라 장기, 중기, 단기 스케줄러로 나뉜다. 스케줄러들은 운영체제 내에 존재하고 있는 프로그램으로, 필요할 때마다 실행파일이 호출되는 것.

▪ 단기 스케줄러
- 대표적으로 cpu scheduler가 short term scheduler이다. i/o bound process와 시분할 시스템 때문에 매우 짧은 시간마다 자주 호출된다.
- ready queue에서 다음 번에 실행될 프로세스를 선택한다.
- 때때로 시스템의 유일한 스케줄러이다. 요즘 컴퓨터는 메모리가 커서 job 스케줄러가 없는 경우도 있기 때문이다.

▪ 중기 스케줄러
- medium term scheduler는 단기 보다는 덜, 장기보다는 자주 호출된다.
- swapping: 쉬고 있는 프로세스를 탐지, 다중프로그래밍의 정도(the degree of multiprogramming)를 줄여준다. 
- 복잡한 메모리 상황을 정리하고, 여러 개의 프로세스 중 어떤 애를 골라서 disk로 뺄지 결정하는 것이 중기 스케줄러이다. 중기 스케줄러는 메모리 공간을 확보함으로써 자원 이용 극대화한다.

▪ 문맥 교환: cpu를 사용하고 있는 아이들을 바꾸는 과정
- 운영체제가 다음 프로세스를 실행해주기 위해서 작업하고 있는 시간 = 문맥 교환 시간
- cpu가 인터럽트 등의 이유에 의해서 현재 실행하고 있는 프로세스가 아닌 다른 프로세스를 실행할 때 문맥 교환이 일어나는데, 문맥 교환은 현재 실행되고 있는 프로세스의 진행 상태까지를 pcb에 저장하고, 다음 들어올 프로세스의 pcb 상태를 cpu에 올리는 것을 말한다.
- 문맥 교환 시간은 오버헤드로, 컴퓨터의 성능을 저하시킬 수 있다.
- 시분할 시스템에서 time slot이 짧을수록 문맥 교환이 너무 많이 일어나며, time-slot이 너무 길면 대기시간이 길어져 시스템의 처리량이 떨어진다.
- 문맥 교환 시간과 time-slot 등은 os가 결정하는 부분이다.

▪ 프로세스 생성
- 부모 프로세스: 자식 프로세스를 생성하는 프로세스
- 자식 프로세스: 부모 프로세스에 의해 생성되는 프로세스
- 프로세스를 계속 생성하다 보면 가계도처럼 트리 구조 형성
- 필요에 의해 생성된 프로세스들은 운영체제 내에서 pid를 통해 구분됨

- 리눅스 운영체제는 메모리에 로드되면 가장 먼저 init 프로세스를 실행시킨다. init 프로세스는 운영체제 실행 기간 내내 함께 실행할 데몬 프로세스(ex. kthreadd, sshd)와 필요에 따라 다른 여러 자식 프로세스(ex. login, bash)들을 생성. 이런 프로세스들은 트리 구조를 이룬다.
* init 프로세스: 시스템 부팅 과정 중 최초의 프로세스, 다른 모든 프로세스들의 직간접적 부모 프로세스. init 프로세스가 다음 3개의 프로세스들을 생성한다.
* login: 사용자 계정을 매개 변수로 받아 실행된다. 로그인쉘, 비밀번호로 사용자 인증 및 사용자 정보 확인, 사용자를 위한 환경 세팅을 한다.
* kthreadd: 커널 관련된 프로세스를 생성하는 데몬 프로세스로 커널 프로세스들의 조상이다.
* sshd: 원격 보안 접속을 위한 데몬 프로세스로 security shell demon process이다.

* fork(): 부모 프로세스를 똑같이 복사한 새로운 프로세스 생성
* exec(): 프로세스의 메모리 공간을 리셋하고 새로운 프로그램으로 대체


	pid > 0



	pid == 0


▪ 프로세스 종료
* exit()
- 프로세스가 사용했던 자원을 운영체제에게 반환, 운영체제에 삭제 요청
- 종료 시점에 자식 프로세스는 wait() 시스템 콜을 사용해서 부모 프로세스에게 상태값을 반환 할 수 있다.

* wait()
- 부모 프로세스가 자식 프로세스의 종료를 기다릴 때
- 자식이 종료된 상태를 부모에게 알리는 방법
- 부모 프로세스 자기 자신을 ready 큐에서 방출하고, waiting 하다가 자식 프로세스가 종료되면 다시 복귀하여 하던 일 재개

* abort() 
- 부모 프로세스가 자식 프로세스의 이상함을 감지했을 때 자식 프로세스를 강제로 종료
- 자식 프로세스가 자신에게 할당된 자원보다 더 많이 사용
- 자식 프로세스의 일이 끝나서 자식 프로세스의 존재가 필요하지 않을 경우
- 부모 프로세스 종료 시 자식 프로세스도 함께 종료시켜야 하는 경우

- 정상적인 작동이 잘 이루어지지 않았을 때 발생하는 프로세스들, 운영체제에게 제대로 자신의 자원을 반환하지 않음 -> 유닉스의 경우, 최상위의 init 프로세스가 주기적으로 wait() 을 호출하여 고아 프로세스들을 수거한다.
* 좀비 프로세스: 자식 프로세스가 종료되었음에도 불구하고 부모가 wait 함수를 호출하지 않은 프로세스
* 고아 프로세스: 부모 프로세스가 wait를 호출하지 않고 종료된 프로세스

▪다중 프로세스 아키텍처
- 익스플로러: 한 웹 사이트에서 문제 발생 시 전체 브라우저에 영향을 미침
- 크롬 브라우저: 여러 개의 프로세스들이 협력해서 작업하는 다중 프로세스로 설계
* browser 프로세스: 사용자 인터페이스, 디스크, 네트워크 I/O 관리
* renderer 프로세스: html, javascript 해석해서 화면에 보여줌, 탭이 열릴 때마다 새로운 renderer 생성, browser가 하는 일에 renderer가 접근할 수 없도록 sandbox에 묶어둠
* plug-in 프로세스: 확장 프로그램, 각 plug-in 종류별로 생성

▪ IPC 통신 모델
- 메시지 전달: 운영체제의 도움을 받아 프로세스 간에 서로 메시지를 주고 받음
- 공유 메모리: 두 프로세스 간에 접근할 수 있는 일종의 버퍼를 만들어 주고 받음(프로그래머가 명시적으로 정의)

▪ 공유 메모리 시스템
- 협력적 프로세스의 전형적인 예: 생산자 - 소비자 문제
- 생산자는 정보를 생산하고 소비가 정보를 소비하는데, 생산한 정보를 어디다 놓고 어떻게 가져갈거냐 하는 문제의 해결책이 공유 메모리이다.
- 공유 메모리는 일종의 버퍼이며, 버퍼를 만든다는 것은 메모리 공간이 필요하다는 것이고, 메모리 공간 즉, 자원을 요청하기 위해서는 운영체제에게 시스템 콜을 통해 요청해야 함.
- 무한 버퍼: 비현실적, 생산자는 대기없이 항상 새로운 항목 생산하여 write 가능, 소비자는 데이터가 있으면 가져오고 버퍼가 비었으면 대기
- 유한 버퍼: 현실적, 생산자가 계속 생산하다가 버퍼가 꽉 차면 대기, 소비자가 계속 소비하다가 버퍼가 비었으면 대기
- 동기화 문제: 생산자와 소비자가 동시에 버퍼에 접속했을 경우 정보가 잘못될 수 있으므로 read와 동시에 write를 하면 안됨

▪ 메시지 전달 시스템
- 하나의 pc 내에 있는 프로세스 보다 서로 멀리 떨어져 있어서 네트워크로 통신을 할 때 사용
- 두 가지 연산 -> 데이터 전송: send(message), 데이터 수신: receive(message)
- 메시지 길이는 다양하며, 고정이면 시스템 구현은 간단하고 프로그래밍은 어려움, 가변이면 시스템 구현은 복잡하고 프로그래밍은 간단함. 일반적으로 네트워크 환경에서는 고정 길이이다.
- 프로세스 P와 Q가 통신하기 원하면 소켓 연결

[과제]
I am the parent 1638
parent1:t_num=5
I am the child 0
newprocess.c test test.out
parent2:t_num=10
Child Complete


---
**참고**  
Operating System Concepts 에센셜/Abraham Silberschatz , Peter Baer Galvin , Greg Gagne/교보문고
